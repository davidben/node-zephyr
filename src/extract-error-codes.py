#!/usr/bin/python
import re
import sys

COMMENT_RE = re.compile(r'^#')
ERROR_TABLE_RE = re.compile(
    r'^[ \t]*(error_table|et)[ \t]+(?P<table>[a-zA-Z][a-zA-Z0-9_]+)')
ERROR_CODE_RE = re.compile(
    r'^[ \t]*(error_code|ec)[ \t]+(?P<code>[A-Z_0-9]+)')
PREFIX_RESET_RE = re.compile(r'^[ \t]*(prefix)')
PREFIX_RE = re.compile(r'^[ \t]*(prefix)[ \t]+(?P<prefix>[A-Z_0-9]+)')
INDEX_RE = re.compile(r'^[ \t]*(index)[ \t]+(?P<index>[A-Z_0-9]+)')

def main():
    prefix = ""
    print "/* Generated by extract-error-codes.py */"
    print
    for line in sys.stdin:
        m = COMMENT_RE.match(line)
        if m:
            continue
        m = ERROR_TABLE_RE.match(line)
        if m:
            print "/* Error table %s */" % m.group("table")
            continue
        m = ERROR_CODE_RE.match(line)
        if m:
            tag = prefix + m.group("code")
            print "#ifdef %s" % tag
            print "NODE_ZEPHYR_ERROR(%s)" % tag
            print "#endif"
            continue
        m = PREFIX_RESET_RE.match(line)
        if m:
            prefix = ""
            continue
        m = PREFIX_RE.match(line)
        if m:
            prefix = m.group("prefix")
            continue
        m = INDEX_RE.match(line)
        if m:
            continue
        # Ignore all other lines. et_c.awk does something complicated
        # with line continuations. et_h.awk just ignores them. Some
        # files put the message on the next line.

if __name__ == "__main__":
    main()
